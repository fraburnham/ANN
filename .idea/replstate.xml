<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1420492408324">{:repl-history {:ide [], :local [&quot;(Math/exp 1)&quot; &quot;(Math/E)&quot; &quot;(loop [u unrolled\n       s structure\n       r []]\n  (if (empty? u)\n    r\n    (recur (drop (first s) u)\n           (rest s)\n           (conj r (take (first s) u)))))&quot; &quot;(* 8 7)&quot; &quot;(map * (partition-all 2 '(3 2 1)))&quot; &quot;(map #(* %1 %2) (partition-all 2 '(3 2 1)))&quot; &quot;(map (fn [x &amp; rest]\n       (if-not (empty? rest)\n         (let [y (first rest)]\n           (* x y))\n         x))\n     (partition-all 2 '(3 2 1)))&quot; &quot;(map (fn [x &amp; rest]\n       (println \&quot;x:\&quot; x \&quot;rest:\&quot; rest)\n       (if-not (empty? rest)\n         (let [y (first rest)]\n           (* x y))\n         x))\n     (partition-all 2 '(3 2 1)))&quot; &quot;(map (fn [x]\n       (println \&quot;x:\&quot; x \&quot;rest:\&quot; rest)\n       (if (&gt; (count x) 1)\n         (let [y (last x)\n               x (first x)]\n           (* x y))\n         (first x)))\n     (partition-all 2 '(3 2 1)))&quot; &quot;(reduce + (map (fn [x]\n                 (if (&gt; (count x) 1)\n                   (let [y (last x)\n                         x (first x)]\n                     (* x y))\n                   (first x)))\n               (partition-all 2 '(3 2 1))))&quot; &quot;(reduce + (map (fn [x]\n                 (if (&gt; (count x) 1)\n                   (let [y (last x)\n                         x (first x)]\n                     (* x y))\n                   (first x)))\n               (partition-all 2 '(12 10 8 7 1))))&quot; &quot;(reduce + (map (fn [x]\n                 (println \&quot;x:\&quot; x)\n                 (if (&gt; (count x) 1)\n                   (let [y (last x)\n                         x (first x)]\n                     (* x y))\n                   (first x)))\n               (partition-all 2 '(12 10 8 7 1))))&quot; &quot;(def structure '(12 10 8 7 1))&quot; &quot;(loop [structure structure\n       d 0]\n  (if (empty? structure)\n    d\n    (recur (rest structure)\n           (+ d (* (first structure) (second structure))))))&quot; &quot;(loop [structure structure\n       d 0]\n  (println structure)\n  (if (empty? structure)\n    d\n    (recur (rest structure)\n           (+ d (* (first structure) (second structure))))))&quot; &quot;(loop [structure structure\n       d 0]\n  (println structure)\n  (if (&lt;= (count structure) 1)\n    d\n    (recur (rest structure)\n           (+ d (* (first structure) (second structure))))))&quot; &quot;(repeatedly 10 [-1 1])&quot; &quot;(repeatedly 10 #([-1 1]))&quot; &quot;(repeatedly 10 #('(-1 1)))&quot; &quot;(repeatedly 10 #(-1 1))&quot; &quot;(repeatedly 10 (fn [] '(-1 1)))&quot; &quot;(repeatedly 10 (fn [] [-1 1]))&quot; &quot;(first (gen-swarm '(3 3 1) 1 (partial apply +)))&quot; &quot;(def particle (first (gen-swarm '(3 3 1) 1 (partial apply +))))&quot; &quot;(defmacro get-position [particle]\n  `(last ~particle))&quot; &quot;(get-position particle)&quot; &quot;(take 3 (get-position particle))&quot; &quot;(cons 1 (take 3 (get-position particle)))&quot; &quot;(concat (take 3 (get-position particle)) 1)&quot; &quot;(conj (take 3 (get-position particle)) 1)&quot; &quot;(conj (into [] (take 3 (get-position particle))) 1)&quot; &quot;(conj (into [] (take 3 (get-position particle))))&quot; &quot;(into [] (take 3 (get-position particle)))&quot; &quot;(def position (get-position particle))&quot; &quot;position&quot; &quot;(partition 3 (take 9 position))&quot; &quot;(def l (into [] (partition 3 (take 9 position))))&quot; &quot;(conj l (take 3 (drop 9 position)))&quot; &quot;(def l (vec (partition 3 (take 9 position))))&quot; &quot;l&quot; &quot;(conj [] l)&quot; &quot;(def l (conj [] l))&quot; &quot;(conj l)&quot; &quot;(conj l (vec (take 3 (drop 9 position))))&quot; &quot;(conj l (vec (list (take 3 (drop 9 position)))))&quot; &quot;(conj l (vec (partition 1 (take 3 (drop 9 position)))))&quot; &quot;(conj l (vec (partition 3 (take 3 (drop 9 position)))))&quot; &quot;(position-to-nn position structure)&quot; &quot;(n/hypothesis '(1 1 0) '(-30 20 20))&quot; &quot;(n/hypothesis [1 1 0] [[-30 20 20]])&quot; &quot;(def inputs '(1 1 0))&quot; &quot;(with-precision (n) 5)&quot; &quot;(with-precision 5 (n/neuron '(1 1 0) '(-30 20 20)))&quot; &quot;(with-precision 1 (n/neuron '(1 1 0) '(-30 20 20)))&quot; &quot;(n/neuron '(1 1 0) '(-30 20 20))&quot; &quot;(n/hypothesis '(1 1 0) '((-30 20 20)))&quot; &quot;(n/hypothesis '(1 1 1) '((-30 20 20)))&quot; &quot;(n/neuron '(1 0 1) '(-30 20 20))&quot; &quot;(n/neuron '(1 1 1) '(-30 20 20))&quot; &quot;(n/hypothesis '(1 0 1) '((-30 20 20)))&quot; &quot;(n/hypothesis '(1 0 1) '(((-30 20 20))))&quot; &quot;(n/hypothesis '(1 1 1) '(((-30 20 20))))&quot; &quot;(def network '(((-30 20 20) (10 -20 -20))\n                ((-10 20 20))))&quot; &quot;(n/hypothesis '(1 0 0) network)&quot; &quot;(n/hypothesis '(1 1 0) network)&quot; &quot;(n/hypothesis '(1 0 1) network)&quot; &quot;(n/hypothesis '(1 1 1) network)&quot; &quot;(def training-in '((1 0 0) (1 1 0) (1 0 1) (1 1 1)))&quot; &quot;(def training-out '(0 1 1 0))&quot; &quot;(def structure '(3 3 1))&quot; &quot;(pso-nn training-in training-out structure 40 0.1 1000)&quot; &quot;(get-dimenstion structure)&quot; &quot;(get-dimension structure)&quot; &quot;(build-space 12)&quot; &quot;(p/generate-swarm 12 (build-space 12) (partial fitness training-in training-out structure))&quot; &quot;(p/generate-swarm 2 '([-1 1] [-1 1]) (partial apply +))&quot; &quot;(p/generate-swarm '([-1 1] [-1 1]) 2 (partial apply +))&quot; &quot;(p/generate-swarm (build-space 12) 40 (partial fitness training-in training-out structure))&quot; &quot;(defn random [low high]\n  (+ (rand (+ high (Math/abs low))) low))\n(def space (build-space 12))\n(map (fn [[min max]] (random min max)) space)&quot; &quot;(def swarm)&quot; &quot;(def swarm [(map (fn [[min max]] (random min max)) space)])&quot; &quot;(def position (map (fn [[min max]] (random min max)) space))&quot; &quot;(p/random-velocity space position)&quot; &quot;(def velocity (p/random-velocity space position))&quot; &quot;(def particle [1 velocity position])&quot; &quot;particle&quot; &quot;(def swarm [particle])&quot; &quot;swarm&quot; &quot;(p/generate-swarm (build-space 2) 3 (partial apply +))&quot; &quot;(p/update-fitness swarm (partial training-in training-out structure))&quot; &quot;(pprint cost)&quot; &quot;(clojure.pprint/pprint cost)&quot; &quot;(clojure.pprint/pprint n/cost)&quot; &quot;(n/cost '(0 1 1 0) '(0.5111368685774282 0.5006274376318193 0.5145844130883996 0.5037663015476643))&quot; &quot;(n/cost '((0) (1) (1) (0)) '((0.5111368685774282) (0.5006274376318193) (0.5145844130883996) (0.5037663015476643)))&quot; &quot;(def training-out (partition 1 training-out))&quot; &quot;training-out&quot; &quot;(require [nn.core :as n])&quot; &quot;(require '[nn.core :as n])&quot; &quot;(p/update-fitness swarm (partial fitness training-in training-out structure))&quot;], :remote []}}</component>
</project>

